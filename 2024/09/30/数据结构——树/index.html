<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Molasses">







<title>Data Structure ———— Tree | Molasses&#39;s Blog</title>



    <link rel="icon" href="/webp.webp">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    




    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>







  <!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Game Craftsmanship.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/">Categories</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/tags/">Tags</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/about/">About</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/Data-Structure/">
                            Data Structure
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                Data Structure ———— Tree
            
            
        </div>
        <span class="post-date">
            Sep 30, 2024
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h2 id="什么是树"><a href="#什么是树" class="headerlink" title="什么是树"></a>什么是树</h2><h2 id="为什么要使用树"><a href="#为什么要使用树" class="headerlink" title="为什么要使用树"></a>为什么要使用树</h2><p>引子一：数据管理中常用的三种操作之一，<font color = "red">查找</font>，通常分为<font color = "red">静态查找</font>和<font color = "red">动态查找</font>，其中静态查找是在一个不变的集合中进行查找。进行静态查找的一个常用方法是顺序查找，即把元素放在数组（或链表里）然后按从前往后或从后往前的顺序逐个元素查找。这种方法的一个明显弊端就是当集合元素数量非常多的时候效率很低，毕竟时间复杂度为O(n)。而动态查找是在一个会动态变化的集合中进行查找，这就涉及对数据结构进行增删，因此数组就不太适合了。</p>
<p>引子二：二分查找是一种很快的搜索算法，时间复杂度是O(logN)，但他的前提条件一是集合已经排序，二是要放在数组里。二分查找为什么这么快？可以理解为不管集合中的元素是什么，二分查找的比较顺序形成了一个层次结构，也就是一棵树，称之为<font color = "red">判定树</font>。<br><img src="https://raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/2023-08-03_002233.png"><br>比如上图，就是对一个11个元素的有序数组进行二分查找的判定树，最上层的元素是6，意思就是二分查找进行判定的第一个元素就是集合中第6个元素（无论这个元素的值是什么），然后下面一层左边是3右边是9，意思是如果第二次判定需要向左查找，则直接判定第3个元素，反之则去判定第9个元素，后面依此类推。</p>
<p>所以说，数组与链表等存储结构可以做到快速查找或灵活变更，但是并不能两者兼具，而树，比如前面的查找树，查找效率可以达到和二分查找差不多，同时在树里插入和删除结点也比数组方便得多。这样的特性使得树非常适合做动态查找的数据结构。</p>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>由n个非空结点组成的集合。特点是子树不相交，除了根结点，每个结点都有且仅有一个父节点。一棵N个结点的树有N-1条边——从每一个叶子结点开始往上都有且仅有一条边连着其父结点（除了根节点没有父结点）所以共有N-1条。</p>
<h2 id="树相关的术语"><a href="#树相关的术语" class="headerlink" title="树相关的术语"></a>树相关的术语</h2><p>结点的度：结点的子树个数<br>树的度：树所有结点中最大的度数<br>叶结点：度为0的结点<br>父结点：有子树的结点是其子树的根结点的父结点<br>结点的层次：根结点在1层，其他任一结点的层数是其父结点层数加1<br>树的深度：所有节点中的最大层次就是这棵树的深度<br>路径和路径长度：从结点n1到nk的路径为一个结点序列n1,n2,…,nk（ni是n（i+1）的父结点，所以路径是从上到下），路径所包含的边的个数为路径的长度。</p>
<h2 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h2><p>数组不太合适，如果用链表搭配结构来实现，通常用“儿子兄弟表示法”来设计结点的结构，即一个结点包含两个指针域，一个指向第一个子节点，另一个指向它的最近的一个兄弟节点。“儿子兄弟表示法”的好处是空间浪费不大。<br><img src="https://raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/2023-08-07_001910.png"><br>我们把用这种表示法的树反转45度会发现，它变成了一棵每个结点有最多两个子节点的树，这就是下面要说的<b>二叉树</b>。事实上，一般的树用“儿子兄弟表示法”表示后都可以看成二叉树的实现，多么奇妙的联系！</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一个有穷的结点集合，可以为空，若非空，则它是由<font color = "blue">根结点</font>和两个名为<font color = "blue">左子树</font>和<font color = "blue">右子树</font>的不相交的二叉树组成。<br>二叉树和一般的度为2的树的区别就是<font color = "red">二叉树的子树有左右顺序之分</font>。</p>
<h3 id="几个重要性质"><a href="#几个重要性质" class="headerlink" title="几个重要性质"></a>几个重要性质</h3><ul>
<li>一个二叉树第$i$层的最大结点数：$2^{i-1}, i\geq1$</li>
<li>深度为$k$的二叉树的最大结点总数：$2^k-1, k\geq1$</li>
<li>对任何非空二叉树T，若$n0$表示叶结点个数，$n2$是度为2的非叶结点个数，那么两者满足关系$n0 &#x3D; n2 +1$</li>
</ul>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>按某顺序访问每个节点。遍历是树最重要的操作，常用的遍历有：</p>
<ul>
<li>先序 —— 根、左子树、右子树</li>
<li>中序 —— 左子树、根、右子树</li>
<li>后序 —— 左子树、右子树、根</li>
<li>层次遍历 —— 从上到下，从左到右</li>
</ul>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><ol>
<li><p>顺序存储结构<br> 一般的树用顺序存储，即数组实现是很困难的，但二叉树因为分支少实现起来相对容易，特别是完全二叉树<br> <img src="https://raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png"><br> <img src="https://raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%912.png"><br> 上图可以看出，对于某有$n$个结点的完全二叉树中序号是$i$的结点，则有如下规律：</p>
<ul>
<li>若其是非根节点，则父结点序号是$i&#x2F;2$（向下取整）</li>
<li>其左子节点序号是$2i$（前提是$2i&lt;n$）</li>
<li>其右子节点序号是$2i+1$（前提是$2i+1&lt;n$）<br> 一般二叉树也可以用数组存储，只是如果相比完全二叉树缺的结点比较多的话会造成空间的浪费。</li>
</ul>
</li>
<li><p>链表存储<br> <img src="https://raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"><br> 每个存储单元包括数据元素Data，指向左子树的指针域Left，指向左子树的指针域Right。</p>
</li>
</ol>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>二叉搜索树（Binary Search Tree，以下简称BST）顾名思义，是二叉树的一种。BST的特点是每个节点的左子树存储的数据小于根数据小于右子树的数据。</p>
<h3 id="二叉搜索树的基本操作"><a href="#二叉搜索树的基本操作" class="headerlink" title="二叉搜索树的基本操作"></a>二叉搜索树的基本操作</h3><p>首先实现一个二叉树的结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TNode</span> *Position;</span><br><span class="line"><span class="keyword">typedef</span> Position BinTree; <span class="comment">/* 二叉树类型 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TNode</span>&#123; <span class="comment">/* 树结点定义 */</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 结点数据 */</span></span><br><span class="line">    BinTree Left;     <span class="comment">/* 指向左子树 */</span></span><br><span class="line">    BinTree Right;    <span class="comment">/* 指向右子树 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><h5 id="查找任意一个元素："><a href="#查找任意一个元素：" class="headerlink" title="查找任意一个元素："></a>查找任意一个元素：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( ElementType X, BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( !BST ) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*查找失败*/</span></span><br><span class="line">	<span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Find</span>( X, BST-&gt;Right ); <span class="comment">/*在右子树中继续查找*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Find</span>( X, BST-&gt;Left ); <span class="comment">/*在左子树中继续查找*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* X == BST-&gt;Data */</span></span><br><span class="line">		<span class="keyword">return</span> BST; <span class="comment">/*查找成功，返回结点的找到结点的地址*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段是使用递归的方式，而且是尾递归（就是在程序分支的最后，也就是要返回的时候才出现递归），这使得效率更低，所以又有下面的循环实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">IterFind</span><span class="params">( ElementType X, BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">while</span>( BST ) &#123;</span><br><span class="line">		 <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">		 	BST = BST-&gt;Right; <span class="comment">/*向右子树中移动，继续查找*/</span></span><br><span class="line">		 <span class="keyword">else</span> <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">		 	BST = BST-&gt;Left; <span class="comment">/*向左子树中移动，继续查找*/</span></span><br><span class="line">		 <span class="keyword">else</span> <span class="comment">/* X == BST-&gt;Data */</span></span><br><span class="line">		 	<span class="keyword">return</span> BST; <span class="comment">/*查找成功，返回结点的找到结点的地址*/</span></span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*查找失败*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，BST的查找效率取决于树的高度，我们希望树的结构尽量平衡，这就是平衡二叉树。</p>
<h5 id="查找最大和最小元素"><a href="#查找最大和最小元素" class="headerlink" title="查找最大和最小元素"></a>查找最大和最小元素</h5><p>根据查找树的特点，可以明确以下两个事实：</p>
<ol>
<li>最大元素一定是在树的最右分枝的端结点上。  </li>
<li>最小元素一定是在树的最左分枝的端结点上。<br>代码实现：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">if</span>( !BST ) </span><br><span class="line">	 	<span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*空的二叉搜索树，返回NULL*/</span></span><br><span class="line">	 <span class="keyword">else</span> <span class="keyword">if</span>( !BST-&gt;Left )</span><br><span class="line">	 	<span class="keyword">return</span> BST; <span class="comment">/*找到最左叶结点并返回*/</span></span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">	 	<span class="keyword">return</span> <span class="built_in">FindMin</span>( BST-&gt;Left ); <span class="comment">/*沿左分支继续查找*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">if</span>(BST )</span><br><span class="line">	 	<span class="keyword">while</span>( BST-&gt;Right )  <span class="comment">/*沿右分支继续查找，直到最右叶结点*/</span></span><br><span class="line">	 		BST = BST-&gt;Right;</span><br><span class="line">	 <span class="keyword">return</span> BST;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>插入的过程和查找任一元素的过程类似，区别就是插入会在查找到要插入的结点位置后，将待插入元素链接到该位置上，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !BST )&#123; <span class="comment">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span></span><br><span class="line">        BST = (BinTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> TNode));</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 开始找要插入元素的位置 */</span></span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Left = <span class="built_in">Insert</span>( BST-&gt;Left, X );   <span class="comment">/*递归插入左子树*/</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Right = <span class="built_in">Insert</span>( BST-&gt;Right, X ); <span class="comment">/*递归插入右子树*/</span></span><br><span class="line">        <span class="comment">/* else X已经存在，什么都不做 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>BST的删除要考虑三种情况：</p>
<ol>
<li>要删除的是叶结点，直接删除，然后修改其父结点指针为NULL;</li>
<li>要删除的结点只有一个孩子结点，将被删除的结点的父结点的指针指向被删除的结点的唯一子结点；</li>
<li>要删除的结点有左、右两棵子树，这种情况稍微复杂一点。策略是用被删除结点的右子树的最小元素或者左子树的最大元素替代被删除结点。</li>
</ol>
<p><strong>值得注意的是：当我们找到元素替代被删除的结点后，我们也要删除用来替代元素。删除该元素的方法也是按照以上3种情况分析</strong>。</p>
<p>代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Position Tmp; </span><br><span class="line">    <span class="keyword">if</span>( !BST ) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到&quot;</span>); </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Left = <span class="built_in">Delete</span>( BST-&gt;Left, X );   <span class="comment">/* 从左子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &gt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Right = <span class="built_in">Delete</span>( BST-&gt;Right, X ); <span class="comment">/* 从右子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; <span class="comment">/* BST就是要删除的结点 */</span></span><br><span class="line">            <span class="comment">/* 如果被删除结点有左右两个子结点 */</span> </span><br><span class="line">            <span class="keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 从右子树中找最小的元素填充删除结点 */</span></span><br><span class="line">                Tmp = <span class="built_in">FindMin</span>( BST-&gt;Right );</span><br><span class="line">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">                <span class="comment">/* 从右子树中删除最小元素 */</span></span><br><span class="line">                BST-&gt;Right = <span class="built_in">Delete</span>( BST-&gt;Right, BST-&gt;Data );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123; <span class="comment">/* 被删除结点有一个或无子结点 */</span></span><br><span class="line">                Tmp = BST; </span><br><span class="line">                <span class="keyword">if</span>( !BST-&gt;Left )       <span class="comment">/* 只有右孩子或无子结点 */</span></span><br><span class="line">                    BST = BST-&gt;Right; </span><br><span class="line">                <span class="keyword">else</span>                   <span class="comment">/* 只有左孩子 */</span></span><br><span class="line">                    BST = BST-&gt;Left;</span><br><span class="line">                <span class="built_in">free</span>( Tmp );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>因为上面介绍的特点，BST的查找和插入操作都很快</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h3><h4 id="为什么要有平衡二叉树"><a href="#为什么要有平衡二叉树" class="headerlink" title="为什么要有平衡二叉树"></a>为什么要有平衡二叉树</h4><p>由上节内容知道，在构建一个二叉树的过程中，插入结点的顺序的不同将导致最终形成的树具有不同的深度和平均查找长度（简称ASL，代表查找效率）。所以当数据按一定顺序插入后可能会形成一直向左或向右延伸的链，这种情况的时间复杂度就成了O(n)，这时便需要我们将二叉树的高度尽可能的降低，使二叉树的高度降低为log(n)，这样我们就得到了一个高度平衡的二叉搜索树，其查找的时间复杂度稳定在O(logn)。</p>
<p>衡量是否高度平衡的概念叫平衡因子 (Balance Factor) ：二叉树上结点的左子树的深度减去其右子树深度称为该结点的平衡因子。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>平衡二叉树</strong>：简称平衡二叉搜索树，所以其本质也是一颗二叉搜索树。由前苏联的数学家 <strong>A</strong>delse-<strong>V</strong>elskil 和 <strong>L</strong>andis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。它可以是空树，如果非空，则具有如下几个性质：</p>
<ol>
<li>左子树和右子树深度之差的绝对值不大于1；</li>
<li>左子树和右子树也都是平衡二叉树。</li>
</ol>
<h3 id="平衡二叉树的存储结构"><a href="#平衡二叉树的存储结构" class="headerlink" title="平衡二叉树的存储结构"></a>平衡二叉树的存储结构</h3><p>和普通的二叉搜索树一样，有左右子节点和数据字段，区别是还要有一个高度来计算平衡因子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TreeNode</span>* left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TreeNode</span>* right;</span><br><span class="line">	<span class="type">int</span> height;       <span class="comment">//和一般二叉搜索树的区别是需要一个高度来计算平衡因子</span></span><br><span class="line">	<span class="built_in">TreeNode</span>(<span class="type">int</span> x, <span class="type">int</span> h = <span class="number">1</span>) :<span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">height</span>(h)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了高度后，再加上获取高度和计算高度的接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取树高</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">AVLGetHeight</span><span class="params">(TreeNode* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算树高（结点增删需要重新计算树高）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AVLCalcHeight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> == node) &#123;              </span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;                                </span><br><span class="line">	node-&gt;height = <span class="number">1</span> + std::<span class="built_in">max</span>(<span class="built_in">AVLGetHeight</span>(node-&gt;left), <span class="built_in">AVLGetHeight</span>(node-&gt;right));</span><br><span class="line">&#125;c</span><br></pre></td></tr></table></figure>

<h3 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h3><p>因为平衡二叉树的特性，插入操作可能导致结果不再是平衡二叉树，所以需要<font color="red">旋转</font>操作来调整。</p>
<p>可能有一个或多个结点的平衡因子绝对值大于1，我们只需要找到最下面的那一个（下面称被破坏者）进行调整。根据插入的结点（下面称破坏者）和被破坏者的位置关系，有以下四种情况：</p>
<ol>
<li>RR，即破坏者位于被破坏者的右子树的右子树上</li>
<li>LL，即破坏者位于被破坏者的左子树的左子树上</li>
<li>RL，即破坏者位于被破坏者的右子树的左子树上</li>
<li>LR，即破坏者位于被破坏者的左子树的右子树上</li>
</ol>
<p>下面用插图来解释一下这四种情况具体的位置关系以及如何调整</p>
<h4 id="1-RR插入"><a href="#1-RR插入" class="headerlink" title="1. RR插入"></a>1. RR插入</h4><p><img src="https://raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/RR%E6%8F%92%E5%85%A5.png"></p>
<p>插入发生在A结点的右节点B的右子树BR上，所以称为RR插入（不论在BR子树中是作为左还是右子节点插入的）。插入发生后，A的平衡因子绝对值就超过了1，所以需要进行旋转调整，操作就是用B取代A的位置作父结点，然后AL、BR不用动，将BL从B的左子树移动到A下面作为右子树就完成了，从旋转后各结点的位置变化上看我们称为左旋。</p>
<p>代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">LRotate</span><span class="params">(TreeNode* T)</span> <span class="comment">//传入结点T是被破坏结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TreeNode* RNode = T-&gt;right;</span><br><span class="line">	T-&gt;right = RNode-&gt;left;</span><br><span class="line">	RNode-&gt;left = T;</span><br><span class="line">	<span class="built_in">AVLCalcHeight</span>(T);</span><br><span class="line">	<span class="built_in">AVLCalcHeight</span>(RNode);</span><br><span class="line">	<span class="keyword">return</span> RNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用一个例子来展示旋转调整过程：</p>
<p><img src="https://raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/RR%E4%BE%8B%E5%AD%90.png"></p>
<h4 id="2-LL插入"><a href="#2-LL插入" class="headerlink" title="2. LL插入"></a>2. LL插入</h4><p><img src="https://raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/LL%E6%97%8B%E8%BD%AC.png"></p>
<p>插入发生在A结点的左节点B的左子树BL上，所以称为LL插入。插入发生后，A的平衡因子绝对值也超过了1，所以需要进行调整，操作同样是用B取代A的位置作父结点，然后两侧的子树AL、BR不用动，将BR从B的右子树移动到A下面作为A的左子树就行，我们称为右旋。</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">LRotate</span><span class="params">(TreeNode* T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TreeNode* LNode = T-&gt;left;</span><br><span class="line">	T-&gt;left = LNode-&gt;right;</span><br><span class="line">	LNode-&gt;right = T;</span><br><span class="line">	<span class="built_in">AVLCalcHeight</span>(T);</span><br><span class="line">	<span class="built_in">AVLCalcHeight</span>(LNode);</span><br><span class="line">	<span class="keyword">return</span> LNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-RL插入"><a href="#3-RL插入" class="headerlink" title="3. RL插入"></a>3. RL插入</h4><p><img src="https://raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/RL%E6%97%8B%E8%BD%AC.png"></p>
<p>插入发生在A结点的右节点B的左子树C上，所以称为RL插入。调整操作是用C取代A的位置作父结点，然后其他需要改变的地方就是将C的两个子树分别加入A和B下。</p>
<p>从另一个角度看，调整过程也可以视为先对B进行右旋，然后再对A进行左旋，所以代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">AVLTreeRL</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">	T-&gt;right = <span class="built_in">LRotate</span>(T-&gt;right);    <span class="comment">// 右子树进行右旋处理并修改T的右指针指向</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">RRotate</span>(T);               <span class="comment">// 对T树进行左旋处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-LR插入"><a href="#4-LR插入" class="headerlink" title="4. LR插入"></a>4. LR插入</h4><p><img src="https://raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/LR%E6%97%8B%E8%BD%AC.png"></p>
<p>插入发生在A结点的左节点B的右子树C上，所以称为LR插入。调整操作也是用C取代A的位置作父结点，然后就是将C的两个子树分别加入B和A下。</p>
<p>同样的，调整过程也可以视为先对B进行左旋，然后再对A进行右旋，所以代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">AVLTreeLR</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">	T-&gt;left = <span class="built_in">LRotate</span>(T-&gt;left);   <span class="comment">//左旋处理并修改T的左指针指向</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">RRotate</span>(T);    <span class="comment">//对T进行右旋处理       </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="平衡二叉树的基本操作"><a href="#平衡二叉树的基本操作" class="headerlink" title="平衡二叉树的基本操作"></a>平衡二叉树的基本操作</h3><h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><p>查找任意值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AVLFind</span><span class="params">(TreeNode* T, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;                        <span class="comment">// 空树</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (data &lt; T-&gt;val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">AVLFind</span>(T-&gt;left, data);       <span class="comment">// data&lt;val，递归查找左子树</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (data &gt; T-&gt;val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">AVLFind</span>(T-&gt;right, data);      <span class="comment">//  data&gt;val，递归查找右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;                             <span class="comment">//  data=val</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找最小值，即找到树的最左结点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">AVLGetMin</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (T &amp;&amp; T-&gt;left)   </span><br><span class="line">		T = T-&gt;left;       </span><br><span class="line">	<span class="keyword">return</span> T;              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找最大值，即找到树的最右结点；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">AVLGetMax</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (T &amp;&amp; T-&gt;right)  </span><br><span class="line">		T = T-&gt;right;      </span><br><span class="line">	<span class="keyword">return</span> T;              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平衡"><a href="#平衡" class="headerlink" title="平衡"></a>平衡</h4><p>每次进行插入或者删除操作的时候，都有可能打破树的平衡性，这时就需要使树重新恢复平衡。 究竟是进行左旋，右旋，还是双旋，就要通过平衡因子来判断了。</p>
<p>令根结点为 T，左子树的根结点为 L，右子树的根结点为 R，aT代表根结点的平衡因子，aL代表左子树根的平衡因子，aR代表右子树根的平衡因子。分为以下四种情况：</p>
<ol>
<li>aT &gt; 1，aL &gt; 0，则为 LL 型，需要进行一次右旋</li>
<li>aT &gt; 1，aL &lt;&#x3D; 0，则为 LR 型，需要进行一次双旋</li>
<li>aT &lt; -1，aR &gt; 0，则为 RL 型，需要进行一次双旋</li>
<li>aT &lt; -1，aR &lt;&#x3D; 0，则为 RR 型，需要进行一次左旋</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">AVLBalance</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> bf = <span class="built_in">AVLGetBalanceFactor</span>(T);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (bf &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">AVLGetBalanceFactor</span>(T-&gt;left) &gt; <span class="number">0</span>)</span><br><span class="line">			T = <span class="built_in">RRotate</span>(T);                 <span class="comment">// LL型，右旋一次</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			T = <span class="built_in">AVLTreeLR</span>(T);                 <span class="comment">// LR型，左旋+右旋 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bf &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">AVLGetBalanceFactor</span>(T-&gt;right) &gt; <span class="number">0</span>)</span><br><span class="line">			T = <span class="built_in">AVLTreeRL</span>(T);                 <span class="comment">// RL型，右旋+左旋 </span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			T = <span class="built_in">LRotate</span>(T);                 <span class="comment">// RR型，左旋一次</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">AVLCalcHeight</span>(T);                         <span class="comment">// 重新计算根结点高度，因为之前旋转时并未完成相关操作</span></span><br><span class="line">	<span class="keyword">return</span> T;                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p>对于要插入的数据 data ，从根结点出发，分情况依次判断：</p>
<ol>
<li>若为空树，则创建一个值为 data 的结点并且返回</li>
<li>data 的值 等于 <strong>树根结点的值</strong>，无须执行插入，直接返回根结点</li>
<li> data 的值 小于 <strong>树根结点的值</strong>，那么插入位置一定在 <strong>左子树</strong>，递归执行插入左子树的过程，并且返回插入结果作为新的<strong>左子树</strong></li>
<li>data 的值 大于 <strong>树根结点的值</strong>，那么插入位置一定在 <strong>右子树</strong>，递归执行插入右子树的过程，并且返回插入结果作为新的<strong>右子树</strong><br>最后，在3或4情况执行完成后，需要对树执行 <strong>平衡</strong> 操作。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">AVLInsert</span><span class="params">(TreeNode* T, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		T = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(data);               <span class="comment">// 空树，创建val=data的结点</span></span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (data == T-&gt;val) &#123;</span><br><span class="line">		<span class="keyword">return</span> T;                              <span class="comment">// data已经存在</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (data &lt; T-&gt;val) &#123;</span><br><span class="line">		T-&gt;left = <span class="built_in">AVLInsert</span>(T-&gt;left, data);    <span class="comment">// 递归查找左子树适合位置，插入 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		T-&gt;right = <span class="built_in">AVLInsert</span>(T-&gt;right, data);  <span class="comment">// 递归查找右子树适合位置，插入 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">AVLBalance</span>(T);                      <span class="comment">// 重新平衡 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><h5 id="删除根节点"><a href="#删除根节点" class="headerlink" title="删除根节点"></a>删除根节点</h5><p>对一棵平衡二叉树，删除它的根结点，需要保证它还是一棵二叉平衡树，则有如下四种情况：</p>
<ol>
<li>空树，无须执行删除，直接返回空；</li>
<li>只有左子树时，将根结点空间释放后，返回左子树；</li>
<li>只有右子树时，将根结点空间释放后，返回右子树；</li>
<li>当左右子树都有时，根据左右子树的平衡性分情况讨论：如果左子树更高，则从左子树选择最大值替换根结点，并且递归删除左子树对应结点；右子树更高，则从右子树选择最小值替换根结点，并且递归删除右子树对应结点；</li>
</ol>
<p>最后，重新计算所有树高，并且返回根结点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除根结点</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">AVLRemoveRoot</span><span class="params">(TreeNode* T)</span> </span>&#123;</span><br><span class="line">	TreeNode* delNode = <span class="literal">nullptr</span>;</span><br><span class="line">	TreeNode* retNode = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;                 <span class="comment">// 空树，直接返回 </span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (T-&gt;right == <span class="literal">nullptr</span>) &#123;    <span class="comment">// 只有左子树（包含单节点情况），释放根结点空间后，返回左子树根结点</span></span><br><span class="line">		retNode = T-&gt;left;</span><br><span class="line">		<span class="keyword">delete</span> T;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;left == <span class="literal">nullptr</span>) &#123;    <span class="comment">// 只有右子树，释放根结点空间后，返回右子树根结点 </span></span><br><span class="line">		retNode = T-&gt;right;</span><br><span class="line">		<span class="keyword">delete</span> T;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;								<span class="comment">// 左右子树都存在 </span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">AVLGetHeight</span>(T-&gt;left) &gt; <span class="built_in">AVLGetHeight</span>(T-&gt;right)) &#123;  <span class="comment">// 左子树高于右子树</span></span><br><span class="line">			retNode = T;</span><br><span class="line">			<span class="comment">//获取左子树最大值结点,并以它的值作为根结点的新值</span></span><br><span class="line">			TreeNode* cur = T-&gt;left;</span><br><span class="line">			TreeNode* pcur = T;</span><br><span class="line">			<span class="keyword">while</span> (cur-&gt;right)</span><br><span class="line">			&#123;</span><br><span class="line">				pcur = cur;</span><br><span class="line">				cur = cur-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">			delNode = cur;</span><br><span class="line">			retNode-&gt;val = cur-&gt;val;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (pcur-&gt;right == cur) &#123;<span class="comment">//左子树的最大值在左子树的右子树上</span></span><br><span class="line">				pcur-&gt;right = cur-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//左子树的最大值为左子树的根</span></span><br><span class="line">				pcur-&gt;left = cur-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> delNode;</span><br><span class="line"> </span><br><span class="line">			</span><br><span class="line">			retNode = <span class="built_in">AVLBalance</span>(T);</span><br><span class="line">			<span class="built_in">AVLCalcAllHeight</span>(retNode);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;   <span class="comment">// 右子树高于左子树</span></span><br><span class="line">			retNode = T;</span><br><span class="line">			<span class="comment">//获取右子树最小值结点,并以它的值作为根结点的新值</span></span><br><span class="line">			TreeNode* cur = T-&gt;right;</span><br><span class="line">			TreeNode* pcur = T;</span><br><span class="line">			<span class="keyword">while</span> (cur-&gt;left)</span><br><span class="line">			&#123;</span><br><span class="line">				pcur = cur;</span><br><span class="line">				cur = cur-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			delNode = cur;</span><br><span class="line">			retNode-&gt;val = cur-&gt;val;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (pcur-&gt;left == cur) &#123;<span class="comment">//右子树的最小值在右子树的左子树上</span></span><br><span class="line">				pcur-&gt;left = cur-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//右子树的最小值为右子树的根</span></span><br><span class="line">				pcur-&gt;right = cur-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> delNode;</span><br><span class="line"> </span><br><span class="line">			retNode = <span class="built_in">AVLBalance</span>(T);</span><br><span class="line">			<span class="built_in">AVLCalcAllHeight</span>(retNode);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除指定根节点"><a href="#删除指定根节点" class="headerlink" title="删除指定根节点"></a>删除指定根节点</h5><p>删除值为 data 的结点的过程，从根结点出发，总共四种情况依次判断：</p>
<ol>
<li>空树，不存在结点，直接返回空 ；</li>
<li>data 的值 等于 树根结点的值，则调用 删除根结点 的接口，这个过程下文会详细介绍；</li>
<li>data 的值 小于 树根结点的值，则需要删除的结点一定不在右子树上，递归调用删除左子树的对应结点，并且将删除结点返回的子树作为新的左子树；</li>
<li>data 的值 大于 树根结点的值，则需要删除的结点一定不在左子树上，递归调用删除右子树的对应结点，并且将删除结点返回的子树作为新的右子树；</li>
</ol>
<p>最后，对于 3 和 4 这两步，需要对树执行 平衡 操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">AVLRemove</span><span class="params">(TreeNode* root,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">nullptr</span> == root) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (val == root-&gt;val) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">AVLRemoveRoot</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">		root-&gt;left = <span class="built_in">AVLRemove</span>(root-&gt;left, val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">		root-&gt;right = <span class="built_in">AVLRemove</span>(root-&gt;right, val);</span><br><span class="line">	&#125;</span><br><span class="line">	root = <span class="built_in">AVLBalance</span>(root);</span><br><span class="line">	<span class="built_in">AVLCalcAllHeight</span>(root);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tips-—-平衡二叉树的最少结点"><a href="#Tips-—-平衡二叉树的最少结点" class="headerlink" title="Tips —- 平衡二叉树的最少结点"></a>Tips —- 平衡二叉树的最少结点</h3><p>根据平衡二叉树的定义，结点数最少的情况时一定是两个子树相差1层，即：<br>                    N(h) &#x3D; N(h−1) + N(h−2) + 1<br>这和斐波那契数列的公式非常接近，转换关系如下：<br>                     N(h) &#x3D; F(h+2) - 1</p>
<p>根据斐波那契数列F和n的关系可以推出当有n个结点时，平衡二叉树的高度h最多为log2n，即：<br>    h &#x3D; $O(\log_2n)$</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>由于AVL树必须保证左右子树平衡，Max(最大树高-最小树高) &lt;&#x3D; 1，所以在插入的时候很容易出现不平衡的情况，一旦这样，就需要进行旋转以求达到平衡。</p>
<p>正是由于这种严格的平衡条件，导致AVL需要花大量时间在调整上，故AVL树一般使用场景在于查询场景， 而不是 增加、删除频繁的场景。</p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2024/05/27/OnGUI%E7%BB%98%E5%88%B6%E4%B8%8EGUIUtility.ExitGUI%E7%9A%84%E4%BD%BF%E7%94%A8/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
