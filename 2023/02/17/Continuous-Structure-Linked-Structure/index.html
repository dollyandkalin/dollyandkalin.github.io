<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Molasses">







<title>Continuous Structure &amp; Linked Structure | Molasses&#39;s Blog</title>



    <link rel="icon" href="/webp.webp">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    




    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>







  <!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            Game Craftsmanship.
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/category/">Categories</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/tags/">Tags</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/about/">About</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/Data-Structure/">
                            Data Structure
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                Continuous Structure &amp; Linked Structure
            
            
        </div>
        <span class="post-date">
            Feb 17, 2023
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <p>根据在内存中存储方式的不同，数据结构可以分为连续存储和链接存储（Linked data structures）两种。连续存储，顾名思义，在内存中由连续相邻的存储单元构成，包括数组，矩阵，堆还有哈希表；链接存储则是有一个个相对独立的内存块构成，这些内存单元不一定相邻，而是由指针将其连接在一起，链接存储包括列表，树，还有图形链接列表。 </p>
<h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h2><p>我们先来看看连续存储结构。<br>数组也许是最基础的连续存储数据结构。普通数组大小长度固定，其中的每个元素可以通过下标快速访问——可以把数组看作一条道路两旁满是房屋的街道，每一个数组元素就是一栋房子，然后数组下标就等于房子的门牌号，假设每栋房子大小相同并且门牌号是从1到n，我们可以由门牌号迅速得到每栋房子的具体位置。<br>连续存储的优点包括：</p>
<ol>
<li><font color ="red"><b>给定索引的情况下访问元素的时间恒定</b></font>。因为数组每个元素的索引直接映射到一个内存地址，所以只要我们知道这个索引就可以立即访问任意数据项；</li>
<li><font color ="red"><b>对内存空间的高效利用</b></font>。数组纯粹由数据组成，不会浪费空间给诸如指针或其他格式信息。另外，由于数组是由固定大小的元素组成，所以也不需要记录结束（截止）信息；</li>
<li><font color ="red"><b>内存局部性</b></font>。许多时候需要遍历数据结构中的所有元素，而数组因为其极好的内存局部性而非常适合实现这一需求。什么是内存局部性？<a target="_blank" rel="noopener" href="https://blog.csdn.net/dzc_go/article/details/109274184">这篇文章</a>可以参考。<br>缺点当然也很明显：我们无法在程序执行中修改其大小。在声明时给数组分配特别大的内存空间？太浪费空间了。一种叫动态数组的存储结构解决了这一问题。当动态数组的存储空间快用尽时，系统会在内存中开辟一块新的存储区域，大小是原来的两倍，原数组中的内容会被拷贝至新数组中的前半部分，然后释放原数组占用的内存空间。<br>直觉上这种处理方式会花费时间在拷贝旧数组的内容到新数组中上，然而真的很浪费吗？当前数组为n的情况下每次扩容数组需要$n^j$次操作，所以总共扩容到大小为n的数组共需要2n的时间<img src="https://raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/2023-02-04_013010.png"><br>所以，动态数组扩容到n的总工作量为$O$(n)，这和预先分配同样大小数组的开销一样。<br>除了那些触发数组扩容的插入，对于动态数组的所有的访问和大多数插入都很快速。总体上，第n个元素插入将足够快，所以算上触发数组扩容的插入开销，总开销仍然是$O$(n)。这种分摊（amortized guarantees）经常出现在数据结构的分析中。</li>
</ol>
<h2 id="2-指针和链接结构"><a href="#2-指针和链接结构" class="headerlink" title="2.指针和链接结构"></a>2.指针和链接结构</h2><p>指针表示内存中的一个位置的地址，链接结构之间通过指针连接在一起。打个比方，手机号码可以看作是指向该号码拥有者的指针。<br>不同语言中的指针不仅语法不同，能力也存在差异。C&#x2F;C++ 和其他语言不同的地方，是指针是可以“计算”的，实际上它的指针实现，就是实际的内存地址，因此它是可以随意修改，灵活性太大的后果，就是太容易误用，造成飞指针，导致程序崩溃。因此，后期设计的语言，都刻意避免可以随意计算无控制的指针，而改用不能计算（类似 Java 里这种）的指针来替代。关于指针的理解知乎上有一个回答挺值得参考，它提出了这样一种解释：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24466000/answer/2258653181">指针其实是内存地址的更高级抽象，这个抽象的目的就在于屏蔽间接寻址</a>。</p>
<p>下面用一个链表结构来说明所有链接结构的一些共性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">	item_type item;  <span class="comment">/* data item */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span>  <span class="comment">/* point to successor */</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/!%5B%5D(https:/raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/2023-02-08_012026.png)"><br><img src="https://raw.githubusercontent.com/dollyandkalin/Image/main/PicGo/2023-02-08_012026.png"></p>
<ul>
<li>链表中每一个节点（list）都包含一个或多个数据字段（item，即我们真正要保存的数据）</li>
<li>每个节点包含一个指向至少一个其他节点的指针字段</li>
<li>最后，我们需要一个指向结构头部的指针，方便我们知道在哪里访问它。<br>这是最简单的链接结构。链表所支持的三个基本操作分别是搜索、插入和删除。在链表中搜索可以迭代或递归地完成：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> *<span class="title function_">search_list</span><span class="params">(<span class="built_in">list</span> *l, item_type x)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (l == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (l-&gt;item == x) &#123;</span><br><span class="line">		<span class="keyword">return</span>(l);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span>(search_list(l-&gt;next, x));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>单链表的插入是指针操作的一个很好的练习，以下是一种实现方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_list</span><span class="params">(<span class="built_in">list</span> **l, item_type x)</span> &#123;</span><br><span class="line">	<span class="built_in">list</span> *p; <span class="comment">/* temporary pointer */</span></span><br><span class="line">	p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">list</span>));</span><br><span class="line">	p-&gt;item = x;</span><br><span class="line">	p-&gt;next = *l;</span><br><span class="line">	*l = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在列表开头插入（如上所示）避免了遍历列表，但需要我们及时将指向数据头部的指针（在这里就是l）正确更新。</p>
<p>从链表中删除稍微复杂一点。首先，我们必须找到一个指向要删除的项的前项的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> *<span class="title function_">item_ahead</span><span class="params">(<span class="built_in">list</span> *l, <span class="built_in">list</span> *x)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ((l == <span class="literal">NULL</span>) || (l-&gt;next == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((l-&gt;next) == x) &#123;</span><br><span class="line">		<span class="keyword">return</span>(l);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span>(item_ahead(l-&gt;next, x));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_list</span><span class="params">(<span class="built_in">list</span> **l, <span class="built_in">list</span> **x)</span> &#123;</span><br><span class="line">	<span class="built_in">list</span> *p;  <span class="comment">/* item pointer */</span></span><br><span class="line">	<span class="built_in">list</span> *pred;  <span class="comment">/* predecessor pointer */</span></span><br><span class="line"></span><br><span class="line">	p = *l;</span><br><span class="line">	pred = item_ahead(*l, *x);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pred == <span class="literal">NULL</span>) &#123; <span class="comment">/* splice out of list */</span></span><br><span class="line">		*l = p-&gt;next;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		pred-&gt;next = (*x)-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(*x);  <span class="comment">/* free memory used by node */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-两种数据结构的比较"><a href="#3-两种数据结构的比较" class="headerlink" title="3.两种数据结构的比较"></a>3.两种数据结构的比较</h2><p>链接结构相对于数组的优点包括：</p>
<ul>
<li>除非内存实际上已满，否则链接结构上永远不会发生溢出</li>
<li>插入和删除比对于静态数组更简单</li>
<li>如果链表中的项目较大，移动指针比移动项目本身更容易、更快。<br>相反，数组的相对优势包括：</li>
<li>无需额外的内存来存储指针字段</li>
<li>对数组中的项的高效随机访问</li>
<li>比指针跳转具有更好的内存局部性和缓存性能。<br>最后补充一个两者相通的地方：都是递归对象。即删除链表第一个元素，剩下的依然是一个链表；把数组前k个元素分割出来得到的是两个较小的数组。这一特性可以启发我们更加灵活简单地处理链表，以及采取一些分治思想算法如快速排序和二分查找。</li>
</ul>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2023/02/17/Container-Stack-Queue/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2023/02/17/Command-Pattern/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
